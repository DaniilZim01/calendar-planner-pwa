
Ты — опытный full-stack разработчик, знакомый с React (TypeScript), PWA, Service Workers, Push API и backend на Express с Drizzle ORM. Помоги добавить полноценную систему push-уведомлений для PWA календарь-планера, которая будет срабатывать, даже когда пользователь не находится в приложении или устройство заблокировано.

## Задачи и требования:

1. **Пуш-уведомления:**
    - Использовать стандартный Push API и Notifications API браузеров.
    - На фронтенде реализовать запрос на разрешение показа уведомлений при первом запуске и возможность отмены разрешения.
    - Настроить Service Worker на принятие push-сообщений и отображение уведомлений.
    - Обеспечить поддержку основных браузеров (Chrome, Firefox, Safari, Edge).
2. **Триггеры уведомлений:**
    - Отправлять уведомления о важных событиях (например, приближение срока задачи или события).
    - Уведомления должны доставляться, даже если PWA неактивно или устройство заблокировано.
    - Предусмотреть возможность персонализации (включение/выключение уведомлений пользователем).
3. **Серверная часть:**
    - Реализовать backend логику подписки на push (сохранять subscription в БД, например, в таблице push_subscriptions, связанной с user_id).
    - Эндпоинты для подписки/отписки на push.
    - Логика отправки push-уведомлений через Web Push Protocol (использовать web-push библиотеку).
    - Организация периодического или событийного пуша напоминаний (например, cron/worker задача для отправки).
4. **Безопасность и конфиденциальность:**
    - Безопасная работа с VAPID-ключами.
    - Политика opt-in для юзеров.
    - Хранение и защита подписок.
5. **UX/UI:**
    - Информировать пользователя о статусе подписки (в профиле).
    - Интеграция с существующими UI-компонентами (например, баннер или модальное окно с запросом разрешения).
    - Показать пример уведомления с заголовком, текстом, иконкой и кнопками действий.
6. **Тестирование:**
    - Тесты для проверки подписки, получения и отображения уведомлений.
    - Инструкции по локальному тестированию push и на проде.

***

## Как это работает сейчас

- Клиент:
  - Регистрация Service Worker в `client/public/service-worker.js` (обрабатывает события `push` и `notificationclick`).
  - Права и подписка: `client/src/lib/push.ts` (+ вызовы из `client/src/pages/profile.tsx`).
  - UI управления: тумблер и «Отправить тест» в профиле. При отправке теста вызывается POST `/api/push` с `action=send`.

- Сервер:
  - Подписка/отписка/отправка: `api/push.js` (однофайловый эндпоинт для экономии лимита функций).
  - БД: таблица `push_subscriptions` (endpoint, p256dh, auth, user_id, created_at, updated_at) и миграции `003_push_subscriptions.sql` + `004_push_subscriptions_tz.sql` (timezone, tz_offset).
  - Отправка пушей: библиотека `web-push`, VAPID-конфиг из `VAPID_SUBJECT`, `VAPID_PUBLIC_KEY`, `VAPID_PRIVATE_KEY`.

- VAPID-ключи:
  - Генерация: `npx web-push generate-vapid-keys`.
  - Настройка: добавить в переменные окружения Vercel `VAPID_PUBLIC_KEY`, `VAPID_PRIVATE_KEY`, `VAPID_SUBJECT` и задеплоить.

- Тестирование:
  - В профиле включить пуши (запрос прав, сохранение подписки в БД), затем нажать «Отправить тест». Уведомление приходит даже при свернутом приложении (при поддержке браузера).

## Как добавить новые уведомления

1) Событийные пуши (по действию в приложении): вызывать `POST /api/push { action: 'send', title, body, url }` после соответствующих событий.

2) Расписание по локальному времени пользователя (пример 09:00 и 21:00):
  - Храним `timezone` и `tz_offset` в `push_subscriptions` (уже поддержано).
  - Добавляем cron‑функцию, которая раз в N минут вычисляет, у кого локально 09:00/21:00 ± допуск, и отправляет push (см. `api/maintenance/*.js`).
  - В Vercel добавить cron‑маршруты в `vercel.json`.

Ограничения: iOS пуши работают для установленной PWA (на Домой) начиная с iOS 16.4; в обычной вкладке Safari — нет. Нужен HTTPS.

